#include <bits/stdc++.h>
using namespace std;
int countPaths(int n, vector<vector<int>> &roads)
{
    vector<vector<pair<long long int, long long int>>> adj(n);
    for (auto i : roads)
    {
        adj[i[0]].push_back({i[1], i[2]});
        adj[i[1]].push_back({i[0], i[2]});
    }

    priority_queue<pair<long long int, long long int>, vector<pair<long long int, long long int>>, greater<pair<long long int, long long int>>> pq;
    vector<long long int> dist(n, INT_MAX);
    vector<long long int> moves(n, 0);

    pq.push({0, 0});
    dist[0] = 0;
    moves[0] = 1;
    int mod = 1e9 + 7;

    while (!pq.empty())
    {
        pair<int, int> p = pq.top();
        pq.pop();

        long long int d = p.first;
        int m = p.second;
        for (auto i : adj[m])
        {
            if (dist[i.first] > d + i.second)
            {
                moves[i.first] = moves[m] % mod;
                dist[i.first] = d + i.second;
                pq.push({dist[i.first], i.first});
            }
            else if (dist[i.first] == d + i.second)
                moves[i.first] = (moves[i.first] + moves[m]) % mod;
        }
    }
    return moves[n - 1];
}

// int countPaths(int n, vector<vector<int>>& grid) {
//         vector <vector <pair <long long, long long>>> graph(n+1);
//         for(auto x: grid) { //creating adjacency list
//             graph[x[0]].push_back({x[1], x[2]});
//             graph[x[1]].push_back({x[0], x[2]});
//         }
//         long long INF = 1e15;
//         long long MOD = 1e9 + 7;
//         vector <long long> dp(n+1, 0);
//         vector <long long> dist(n+1, INF);
//         priority_queue <pair <long long, long long>> q; // maxHeap in c++
// 		// although we can use use minHeap in c++ by adding parameter to the maxHeap template
// 		// but I have inserted -1*val into the maxHeap so it worked fine as minHeap
		
//         dist[0] = 0;
//         dp[0] = 1; // initilize it to 1 since to reach 0 we have 1 way
//         q.push({0, 0});
		
//         while(q.size()) {
//             long long node = q.top().second;
//             long long nodeWt = -q.top().first;
//             q.pop();

// 			/*
// 			what if we inserted min weight after some greater weight and we always pop min weight so it can be
// 			possible that some nodeWt (> dist[node]) is there in the queue that we haven't popped yet...
// 			hence we are continuing so that we don't traverse adjacency list of node again
			
// 			I have taken a graph as an example below the code.
// 			*/
//             if(dist[node] < nodeWt) continue; // explained above
//             for(auto key: graph[node]) {
//                 long long child = key.first;
//                 long long childWt = key.second;
//                 if(nodeWt + childWt == dist[child]) {
// 					// we are adding parent's dp value to child's dp 
//                     dp[child] = (dp[child] + dp[node])%MOD;
//                 }
//                 if(nodeWt + childWt < dist[child]) {
//                     dp[child] = dp[node]%MOD; // we are getting value of parent's dp
//                     dist[child] = nodeWt + childWt;
//                     q.push({-dist[child], child});
//                 }
//             }
//         }
//         return dp[n-1];
//     }
int main()
{
    vector<vector<int>> roads={{0,1,1000000000},{1,2,1000000000},{2,3,1000000000},{3,4,1000000000},{4,5,1000000000},{5,6,1000000000},{6,7,1000000000},{7,8,1000000000},{8,9,1000000000},{9,10,1000000000},{10,11,1000000000},{11,12,1000000000},{12,13,1000000000},{13,14,1000000000},{14,15,1000000000},{15,16,1000000000},{16,17,1000000000},{17,18,1000000000},{18,19,1000000000},{19,20,1000000000},{20,21,1000000000},{21,22,1000000000},{22,23,1000000000},{23,24,1000000000},{24,25,1000000000},{25,26,1000000000},{26,27,1000000000},{27,28,1000000000},{28,29,1000000000},{29,30,1000000000},{30,31,1000000000},{31,32,1000000000},{32,33,1000000000},{33,34,1000000000},{34,35,1000000000},{35,36,1000000000},{36,37,1000000000},{37,38,1000000000},{38,39,1000000000},{39,40,1000000000},{40,41,1000000000},{41,42,1000000000},{42,43,1000000000},{43,44,1000000000},{44,45,1000000000},{45,46,1000000000},{46,47,1000000000},{47,48,1000000000},{48,49,1000000000},{49,50,1000000000},{50,51,1000000000},{51,52,1000000000},{52,53,1000000000},{53,54,1000000000},{54,55,1000000000},{55,56,1000000000},{56,57,1000000000},{57,58,1000000000},{58,59,1000000000},{59,60,1000000000},{60,61,1000000000},{61,62,1000000000},{62,63,1000000000},{63,64,1000000000},{64,65,1000000000},{65,66,1000000000},{66,67,1000000000},{67,68,1000000000},{68,69,1000000000},{69,70,1000000000},{70,71,1000000000},{71,72,1000000000},{72,73,1000000000},{73,74,1000000000},{74,75,1000000000},{75,76,1000000000},{76,77,1000000000},{77,78,1000000000},{78,79,1000000000},{79,80,1000000000},{80,81,1000000000},{81,82,1000000000},{82,83,1000000000},{83,84,1000000000},{84,85,1000000000},{85,86,1000000000},{86,87,1000000000},{87,88,1000000000},{88,89,1000000000},{89,90,1000000000},{90,91,1000000000},{91,92,1000000000},{92,93,1000000000},{93,94,1000000000},{94,95,1000000000},{95,96,1000000000},{96,97,1000000000},{97,98,1000000000},{98,99,1000000000},{99,100,1000000000},{100,101,1000000000},{101,102,1000000000},{102,103,1000000000},{103,104,1000000000},{104,105,1000000000},{105,106,1000000000},{106,107,1000000000},{107,108,1000000000},{108,109,1000000000},{109,110,1000000000},{110,111,1000000000},{111,112,1000000000},{112,113,1000000000},{113,114,1000000000},{114,115,1000000000},{115,116,1000000000},{116,117,1000000000},{117,118,1000000000},{118,119,1000000000},{119,120,1000000000},{120,121,1000000000},{121,122,1000000000},{122,123,1000000000},{123,124,1000000000},{124,125,1000000000},{125,126,1000000000},{126,127,1000000000},{127,128,1000000000},{128,129,1000000000},{129,130,1000000000},{130,131,1000000000},{131,132,1000000000},{132,133,1000000000},{133,134,1000000000},{134,135,1000000000},{135,136,1000000000},{136,137,1000000000},{137,138,1000000000},{138,139,1000000000},{139,140,1000000000},{140,141,1000000000},{141,142,1000000000},{142,143,1000000000},{143,144,1000000000},{144,145,1000000000},{145,146,1000000000},{146,147,1000000000},{147,148,1000000000},{148,149,1000000000},{149,150,1000000000},{150,151,1000000000},{151,152,1000000000},{152,153,1000000000},{153,154,1000000000},{154,155,1000000000},{155,156,1000000000},{156,157,1000000000},{157,158,1000000000},{158,159,1000000000},{159,160,1000000000},{160,161,1000000000},{161,162,1000000000},{162,163,1000000000},{163,164,1000000000},{164,165,1000000000},{165,166,1000000000},{166,167,1000000000},{167,168,1000000000},{168,169,1000000000},{169,170,1000000000},{170,171,1000000000},{171,172,1000000000},{172,173,1000000000},{173,174,1000000000},{174,175,1000000000},{175,176,1000000000},{176,177,1000000000},{177,178,1000000000},{178,179,1000000000},{179,180,1000000000},{180,181,1000000000},{181,182,1000000000},{182,183,1000000000},{183,184,1000000000},{184,185,1000000000},{185,186,1000000000},{186,187,1000000000},{187,188,1000000000},{188,189,1000000000},{189,190,1000000000},{190,191,1000000000},{191,192,1000000000},{192,193,1000000000},{193,194,1000000000},{194,195,1000000000},{195,196,1000000000},{196,197,1000000000},{197,198,1000000000},{198,199,1000000000}};

    cout<<countPaths(200,roads);
}